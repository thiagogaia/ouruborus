---
name: flask-patterns
description: Padrões e boas práticas para Flask. Use quando criar blueprints, routes,
  models, schemas (Marshmallow), error handlers, ou integrar com SQLAlchemy,
  Celery e Redis. Também para troubleshooting de session management, CORS,
  request context e factory pattern.
---

# Flask Patterns

## Application Factory

SEMPRE usar factory pattern. Nunca instanciar Flask no escopo global.

```python
# app/__init__.py
from flask import Flask

def create_app(config_name="default"):
    app = Flask(__name__)
    app.config.from_object(config[config_name])

    # Extensions
    db.init_app(app)
    migrate.init_app(app, db)
    ma.init_app(app)

    # Blueprints
    from app.auth import auth_bp
    from app.api import api_bp
    app.register_blueprint(auth_bp, url_prefix="/auth")
    app.register_blueprint(api_bp, url_prefix="/api")

    # Error handlers
    register_error_handlers(app)

    return app
```

## Estrutura de Projeto

```
app/
├── __init__.py          # create_app factory
├── config.py            # Config classes por environment
├── extensions.py        # db, ma, migrate (init sem app)
├── auth/
│   ├── __init__.py      # Blueprint
│   ├── routes.py
│   └── decorators.py
├── api/
│   ├── __init__.py      # Blueprint
│   └── v1/
│       ├── __init__.py
│       ├── items.py     # Routes
│       └── schemas.py   # Marshmallow schemas
├── models/
│   ├── __init__.py
│   ├── item.py
│   └── user.py
├── services/
│   ├── __init__.py
│   └── item_service.py  # Business logic
└── utils/
    ├── __init__.py
    └── responses.py     # Helpers de response padronizado
```

## Extensions (sem circular import)

```python
# extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from flask_migrate import Migrate

db = SQLAlchemy()
ma = Marshmallow()
migrate = Migrate()
```

**Regra**: Instanciar extensions SEM app. Chamar `init_app()` dentro do factory.

## Blueprints

Cada domínio = 1 Blueprint. Agrupa routes, schemas e lógica relacionada.

```python
# app/api/__init__.py
from flask import Blueprint
api_bp = Blueprint("api", __name__)

from app.api.v1 import items  # noqa: importa routes ao final
```

```python
# app/api/v1/items.py
from flask import request, jsonify
from app.api import api_bp
from app.services.item_service import ItemService
from app.api.v1.schemas import ItemSchema, CreateItemSchema

item_schema = ItemSchema()
items_schema = ItemSchema(many=True)
create_schema = CreateItemSchema()

@api_bp.route("/v1/items", methods=["GET"])
def list_items():
    page = request.args.get("page", 1, type=int)
    per_page = request.args.get("per_page", 20, type=int)
    items = ItemService.list_paginated(page=page, per_page=per_page)
    return jsonify(items_schema.dump(items)), 200

@api_bp.route("/v1/items", methods=["POST"])
def create_item():
    data = create_schema.load(request.get_json())
    item = ItemService.create(data)
    return jsonify(item_schema.dump(item)), 201

@api_bp.route("/v1/items/<uuid:item_id>", methods=["GET"])
def get_item(item_id):
    item = ItemService.get_or_404(item_id)
    return jsonify(item_schema.dump(item)), 200
```

## Models (SQLAlchemy)

```python
# app/models/item.py
from app.extensions import db
from sqlalchemy.dialects.postgresql import UUID
import uuid

class Item(db.Model):
    __tablename__ = "items"

    id = db.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = db.Column(db.String(255), nullable=False)
    status = db.Column(db.String(20), default="active", index=True)
    price = db.Column(db.Numeric(10, 2), nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.now())
    updated_at = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())
    deleted_at = db.Column(db.DateTime, nullable=True)  # soft delete

    @property
    def is_active(self):
        return self.deleted_at is None

    def soft_delete(self):
        self.deleted_at = db.func.now()
        db.session.commit()

    def __repr__(self):
        return f"<Item {self.name}>"
```

## Schemas (Marshmallow)

Separar schemas de input e output. SEMPRE validar via Marshmallow, nunca manualmente.

```python
# app/api/v1/schemas.py
from app.extensions import ma
from marshmallow import fields, validate

class ItemSchema(ma.Schema):
    id = fields.UUID(dump_only=True)
    name = fields.String(required=True)
    status = fields.String(dump_only=True)
    price = fields.Decimal(as_string=True)
    created_at = fields.DateTime(dump_only=True)

class CreateItemSchema(ma.Schema):
    name = fields.String(required=True, validate=validate.Length(min=1, max=255))
    price = fields.Decimal(required=True, validate=validate.Range(min=0))
    status = fields.String(
        load_default="active",
        validate=validate.OneOf(["active", "inactive"])
    )
```

**Regra**: `dump_only=True` para campos de output. `load_default` para defaults de input.

## Services (Lógica de negócio)

```python
# app/services/item_service.py
from flask import abort
from app.extensions import db
from app.models.item import Item

class ItemService:
    @staticmethod
    def create(data: dict) -> Item:
        item = Item(**data)
        db.session.add(item)
        db.session.commit()
        return item

    @staticmethod
    def get_or_404(item_id) -> Item:
        item = Item.query.filter_by(id=item_id, deleted_at=None).first()
        if not item:
            abort(404, description=f"Item {item_id} not found")
        return item

    @staticmethod
    def list_paginated(page=1, per_page=20):
        return Item.query.filter_by(deleted_at=None)\
            .order_by(Item.created_at.desc())\
            .paginate(page=page, per_page=per_page, error_out=False)\
            .items
```

## Error Handlers

```python
# app/utils/errors.py
from flask import jsonify

def register_error_handlers(app):
    @app.errorhandler(400)
    def bad_request(e):
        return jsonify({"error": "Bad Request", "message": str(e)}), 400

    @app.errorhandler(404)
    def not_found(e):
        return jsonify({"error": "Not Found", "message": str(e.description)}), 404

    @app.errorhandler(422)
    def unprocessable(e):
        return jsonify({"error": "Validation Error", "messages": e.data.get("messages", {})}), 422

    @app.errorhandler(500)
    def internal_error(e):
        return jsonify({"error": "Internal Server Error"}), 500
```

## Config por Environment

```python
# app/config.py
import os

class Config:
    SECRET_KEY = os.environ.get("SECRET_KEY", "change-me")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get("DATABASE_URL", "sqlite:///dev.db")

class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ["DATABASE_URL"]

config = {
    "default": DevelopmentConfig,
    "development": DevelopmentConfig,
    "production": ProductionConfig,
}
```

## Celery (Background Tasks)

```python
# app/celery_app.py
from celery import Celery

def make_celery(app):
    celery = Celery(app.import_name, broker=app.config["CELERY_BROKER_URL"])
    celery.conf.update(app.config)

    class ContextTask(celery.Task):
        def __call__(self, *args, **kwargs):
            with app.app_context():
                return self.run(*args, **kwargs)

    celery.Task = ContextTask
    return celery
```

**Regra**: SEMPRE executar tasks dentro do `app_context()`.

## Regras

- NUNCA instancie Flask globalmente — use factory pattern (`create_app`)
- NUNCA coloque lógica de negócio em routes — use services
- SEMPRE valide input via Marshmallow schemas, não manualmente
- SEMPRE use soft deletes por padrão (`deleted_at`)
- SEMPRE registre error handlers globais para respostas consistentes
- NUNCA exponha models diretamente — use schemas de response
- Um Blueprint por domínio — não misture responsabilidades
- Use `flask-migrate` para todas as mudanças de schema
- Celery tasks SEMPRE dentro de `app_context()`
- Config via variáveis de ambiente, nunca hardcoded
